import sys
import re

def parse_memory_operand(operand):
    match = re.match(r"(\d+)\((R\d+)\)", operand)
    if match:
        immediate = int(match.group(1))  # The immediate value (e.g., 4)
        register = int(match.group(2)[1])  # Extract the register number (e.g., R2 -> 2)
        return immediate, register
    else:
        raise ValueError(f"Invalid memory operand format: {operand}")
# Simulator Constants
REGISTER_COUNT = 8  # R0 to R7
MEMORY_SIZE = 128 * 1024  # 128 KB word-addressable memory

class RegisterFile:
    def __init__(self, num_registers):
        self.values = [0] * num_registers  # Register values
        self.status = [None] * num_registers  # None if register is ready

    def get_value(self, reg_index):
        return self.values[reg_index]

    def set_value(self, reg_index, value):
        self.values[reg_index] = value

    def is_ready(self, reg_index):
        return self.status[reg_index] is None

    def set_status(self, reg_index, station_name):
        self.status[reg_index] = station_name

    def clear_status(self, reg_index):
        self.status[reg_index] = None
        
class Memory:
    def __init__(self, size):
        self.memory = [0] * size

    def load(self, address):
        return self.memory[address]

    def store(self, address, value):
        self.memory[address] = value

class Instruction:
    def __init__(self, operation, operands):
        self.operation = operation
        self.operands = operands
        
def parse_instruction(line):
    parts = line.strip().split()
    operation = parts[0]
    operands = [op.strip(',') for op in parts[1:]]
    return Instruction(operation, operands)

def load_program(file_path):
    instructions = []
    try:
        with open(file_path, 'r') as file:
            for line in file:
                if line.strip():
                    instructions.append(parse_instruction(line))
    except FileNotFoundError:
        print(f"Error: File {file_path} not found.")
        sys.exit(1)
    return instructions

class InstructionQueue:
    def __init__(self):
        self.queue = []

    def add(self, instruction):
        self.queue.append(instruction)

    def fetch(self):
        return self.queue.pop(0) if self.queue else None

    def is_empty(self):
        return len(self.queue) == 0
        
    def flush(self):
        """Flush the entire queue."""
        self.queue = []
    
    def flush_after(self, branch_index):
        # Remove all instructions after the branch_index
        self.queue = self.queue[:branch_index + 1]


class ReservationStation:
    def __init__(self, name, num_stations, execution_cycles, op_type=None):
        self.name = name
        self.num_stations = num_stations
        self.execution_cycles = execution_cycles
        self.op_type = op_type
        self.stations = [{'busy': False, 'op': None, 'Vj': None, 'Vk': None, 'Qj': None, 'Qk': None, 'cycles_left': 0, 'address': None}
                         for _ in range(num_stations)]

    def is_available(self):
        return any(not station['busy'] for station in self.stations)

    def allocate(self, op, Vj=None, Vk=None, Qj=None, Qk=None, address=None):
        for station in self.stations:
            if not station['busy']:
                station.update({'busy': True, 'op': op, 'Vj': Vj, 'Vk': Vk, 'Qj': Qj, 'Qk': Qk, 'cycles_left': self.execution_cycles, 'address': address})
                return station
        return None

    def execute(self, register_file, memory):
        for station in self.stations:
            if station['busy'] and station['cycles_left'] > 0:
                station['cycles_left'] -= 1
    
                # Execution logic for different operations
                if station['cycles_left'] == 0:
                    if station['op'] == "ADD":
                        result = station['Vj'] + station['Vk']
                        print(f"ADD Result: {result}")
                    elif station['op'] == "SUB":
                        result = station['Vj'] - station['Vk']
                        print(f"SUB Result: {result}")
                    elif station['op'] == "LOAD":
                        result = memory.load(station['address'])
                        print(f"LOAD Result: {result}")
                    elif station['op'] == "STORE":
                        memory.store(station['address'], station['Vj'])
                        print(f"STORE: Stored {station['Vj']} at address {station['address']}")
    
                    # Store the result back to the register if needed
                    if station['op'] in ["ADD", "SUB"]:
                        # Ensure Qj is not None before using it as an index
                        if station['Qj'] is not None:
                            register_file.set_value(station['Qj'], result)
                        else:
                            print(f"Warning: Qj is None, skipping write back.")
    
                    # Release the station after execution
                    station['busy'] = False
                    return station
        return None


    def release(self, station):
        station.update({'busy': False, 'op': None, 'Vj': None, 'Vk': None, 'Qj': None, 'Qk': None, 'cycles_left': 0, 'address': None})

def resolve_operands(register_file, operands):
    Vj, Vk, Qj, Qk = None, None, None, None

    if operands[0].startswith('R'):  # First operand, for example, "R1"
        reg_index = int(operands[0][1:])  # Extract register index (e.g., "R1" -> 1)
        if 0 <= reg_index < REGISTER_COUNT:
            Vj = register_file.get_value(reg_index)
            if register_file.status[reg_index] is not None:  # Register is pending
                Qj = register_file.status[reg_index]
        else:
            print(f"Error: Register {reg_index} out of bounds for operand {operands[0]}")

    if operands[1].startswith('R'):  # Second operand, for example, "R0"
        reg_index = int(operands[1][1:])  # Extract register index (e.g., "R0" -> 0)
        if 0 <= reg_index < REGISTER_COUNT:
            Vk = register_file.get_value(reg_index)
            if register_file.status[reg_index] is not None:  # Register is pending
                Qk = register_file.status[reg_index]
        else:
            print(f"Error: Register {reg_index} out of bounds for operand {operands[1]}")

    return Vj, Vk, Qj, Qk

class ReorderBuffer:
    def __init__(self, size):
        # Each entry holds:
        # - 'busy': whether the entry is occupied
        # - 'instruction': the actual instruction
        # - 'state': current state of the instruction ('issue', 'execute', 'write', 'commit')
        # - 'result': the computed result, or None if not yet computed
        # - 'destination': destination register, if the instruction writes back
        self.entries = [{'busy': False, 'instruction': None, 'state': 'issue', 'result': None, 'destination': None}
                        for _ in range(size)]

    def add(self, instruction, destination=None):
        """ Adds an instruction to the reorder buffer. """
        for entry in self.entries:
            if not entry['busy']:  # Find an empty slot
                entry.update({
                    'busy': True,
                    'instruction': instruction,
                    'state': 'issue',
                    'result': None,
                    'destination': destination  # Where to write the result, if any
                })
                return entry
        return None

    def write_result(self, instruction, result):
        """ Writes a result back to the reorder buffer when execution is complete. """
        for entry in self.entries:
            if entry['busy'] and entry['instruction'] == instruction:
                entry['state'] = 'write'  # Once result is available, mark as ready to write
                entry['result'] = result
                return True
        return False

    def commit(self, current_cycle, metadata, register_file):
        """ Commits completed instructions from the reorder buffer to the register file. """
        for entry in self.entries:
            if entry['busy'] and entry['state'] == 'write':  # Instruction is ready to commit
                entry['state'] = 'commit'
                entry['busy'] = False
                # Update the register file or memory based on the instruction's result
                if entry['destination']:
                    register_file.write(entry['destination'], entry['result'])

                # Also update metadata for instruction commit cycle
                for meta in metadata:
                    if meta['instruction'] == entry['instruction'] and meta.get('commit') is None:
                        meta['commit'] = current_cycle
                        break
                return True
        return False



    def __init__(self, instructions):
        self.instructions = instructions
        self.current_cycle = 0
        self.instruction_states = []  # To track each instruction's lifecycle
    
    def simulate(self):
        while not self.is_program_complete():
            self.current_cycle += 1
            self.advance_simulation()
        
        self.print_results()

    def advance_simulation(self):
        # Process instructions and update their states (e.g., issue, execute, write, commit)
        for instruction in self.instructions:
            if instruction.can_issue(self.current_cycle):
                instruction.issue_cycle = self.current_cycle
            if instruction.can_start_execution(self.current_cycle):
                instruction.start_exec_cycle = self.current_cycle
            if instruction.can_finish_execution(self.current_cycle):
                instruction.finish_exec_cycle = self.current_cycle
            if instruction.can_write_result(self.current_cycle):
                instruction.write_result_cycle = self.current_cycle
            if instruction.can_commit(self.current_cycle):
                instruction.commit_cycle = self.current_cycle

    def is_program_complete(self):
        return all(instr.commit_cycle > 0 for instr in self.instructions)

    def print_results(self):
        print("Instruction Execution Table:")
        print(f"{'Instruction':<20}{'Issue':<10}{'Start Exec':<15}{'Finish Exec':<15}{'Write Result':<15}{'Commit':<10}")
        
        total_instructions = len(self.instructions)
        total_cycles = 0
        
        for instr in self.instructions:
            print(f"{instr.name:<20}{instr.issue_cycle:<10}{instr.start_exec_cycle:<15}{instr.finish_exec_cycle:<15}"
                  f"{instr.write_result_cycle:<15}{instr.commit_cycle:<10}")
            total_cycles = max(total_cycles, instr.commit_cycle)
        
        ipc = total_instructions / total_cycles if total_cycles > 0 else 0
        print("\nSimulation Results:")
        print(f"Total Cycles: {total_cycles}")
        print(f"IPC: {ipc:.2f}")

def simulate(instructions):
    current_cycle = 0
    while not is_program_complete(instructions):
        current_cycle += 1
        advance_simulation(instructions, current_cycle)
    print_results(instructions)

def advance_simulation(instructions, current_cycle):
    for instruction in instructions:
        if instruction.can_issue(current_cycle):
            instruction.issue_cycle = current_cycle
        if instruction.can_start_execution(current_cycle):
            instruction.start_exec_cycle = current_cycle
        if instruction.can_finish_execution(current_cycle):
            instruction.finish_exec_cycle = current_cycle
        if instruction.can_write_result(current_cycle):
            instruction.write_result_cycle = current_cycle
        if instruction.can_commit(current_cycle):
            instruction.commit_cycle = current_cycle

def is_program_complete(instructions):
    return all(instr.commit_cycle > 0 for instr in instructions)

def print_results(instructions):
    print("Instruction Execution Table:")
    print(f"{'Instruction':<20}{'Issue':<10}{'Start Exec':<15}{'Finish Exec':<15}{'Write Result':<15}{'Commit':<10}")
    
    total_instructions = len(instructions)
    total_cycles = 0
    
    for instr in instructions:
        print(f"{instr.name:<20}{instr.issue_cycle:<10}{instr.start_exec_cycle:<15}{instr.finish_exec_cycle:<15}"
              f"{instr.write_result_cycle:<15}{instr.commit_cycle:<10}")
        total_cycles = max(total_cycles, instr.commit_cycle)
    
    ipc = total_instructions / total_cycles if total_cycles > 0 else 0
    print("\nSimulation Results:")
    print(f"Total Cycles: {total_cycles}")
    print(f"IPC: {ipc:.2f}")


def main():
    register_file = RegisterFile(REGISTER_COUNT)
    memory = Memory(MEMORY_SIZE)
    instruction_queue = InstructionQueue()

    # Initialize reservation stations for different operations
    add_station = ReservationStation("ADD", 2, 2, op_type="ADD")
    sub_station = ReservationStation("SUB", 2, 2, op_type="SUB")
    load_station = ReservationStation("LOAD", 2, 6, op_type="LOAD")
    store_station = ReservationStation("STORE", 1, 6, op_type="STORE")
    nand_station = ReservationStation("NAND", 2, 2, op_type="NAND")
    branch_station = ReservationStation("BEQ", 2, 1, op_type="BEQ")

    # Load instructions
    program_path = "test1"
    instructions = load_program(program_path)
    
    # Add instructions to the queue
    for instr in instructions:
        instruction_queue.add(instr)

    clock_cycles = 0
    completed_instructions = 0
    total_instructions = len(instructions)
    
    # Headers for the table
    print(f"{'Cycle':<6}{'ADD':<20}{'LOAD':<20}{'STORE':<20}{'NAND':<20}{'BEQ':<20}")

    while not instruction_queue.is_empty():
        current_instruction = instruction_queue.fetch()

        # Initialize row for the current cycle
        cycle_row = f"{clock_cycles:<6}"

        # Dispatch instructions to reservation stations
        if current_instruction.operation == "ADD" and add_station.is_available():
            Vj, Vk, Qj, Qk = resolve_operands(register_file, current_instruction.operands)
            add_station.allocate(current_instruction.operation, Vj=Vj, Vk=Vk, Qj=Qj, Qk=Qk)
            result = add_station.execute(register_file, memory)
            cycle_row += f"ADD Result: {result:<15}"
        else:
            cycle_row += f"ADD Pending{' ' * 4}"

        if current_instruction.operation == "LOAD" and load_station.is_available():
            Vj, Vk, Qj, Qk = resolve_operands(register_file, current_instruction.operands)
            offset, reg_index = parse_memory_operand(current_instruction.operands[1])
            if reg_index < REGISTER_COUNT:
                load_station.allocate(current_instruction.operation, address=offset + register_file.get_value(reg_index), Vj=Vj, Vk=Vk, Qj=Qj, Qk=Qk)
                result = load_station.execute(register_file, memory)
                cycle_row += f"LOAD Result: {result:<15}"
            else:
                cycle_row += "LOAD Error       "
        else:
            cycle_row += "LOAD Pending      "

        if current_instruction.operation == "STORE" and store_station.is_available():
            Vj, Vk, Qj, Qk = resolve_operands(register_file, current_instruction.operands)
            offset, reg_index = parse_memory_operand(current_instruction.operands[1])
            if reg_index < REGISTER_COUNT:
                store_station.allocate(current_instruction.operation, Vj=Vj, address=offset + register_file.get_value(reg_index), Qj=Qj, Qk=Qk)
                result = store_station.execute(register_file, memory)
                cycle_row += f"STORE: Stored {result} at address {offset + register_file.get_value(reg_index)}"
            else:
                cycle_row += "STORE Error      "
        else:
            cycle_row += "STORE Pending     "
        
        if current_instruction.operation == "NAND" and nand_station.is_available():
            Vj, Vk, Qj, Qk = resolve_operands(register_file, current_instruction.operands)
            nand_station.allocate(current_instruction.operation, Vj=Vj, Vk=Vk, Qj=Qj, Qk=Qk)
            result = nand_station.execute(register_file, memory)
            cycle_row += f"NAND Result: {result:<15}"
        else:
            cycle_row += "NAND Pending      "

        if current_instruction.operation == "BEQ" and branch_station.is_available():
            reg1_index = int(current_instruction.operands[0][1:])
            reg2_index = int(current_instruction.operands[1][1:])
            if 0 <= reg1_index < REGISTER_COUNT and 0 <= reg2_index < REGISTER_COUNT:
                Vj, Vk, _, _ = resolve_operands(register_file, current_instruction.operands)
                if Vj == Vk:
                    cycle_row += f"Branch taken: {current_instruction.operands[0]} == {current_instruction.operands[1]}"
                    instruction_queue.flush_after(len(instruction_queue.queue) - 1)
                else:
                    cycle_row += "Branch not taken "
            else:
                cycle_row += "BEQ Error         "
        else:
            cycle_row += "BEQ Pending        "

        # Print the cycle row for the current cycle
        print(cycle_row)

        # Release completed stations
        completed_station_add = add_station.execute(register_file, memory)
        if completed_station_add:
            add_station.release(completed_station_add)
            completed_instructions += 1

        completed_station_sub = sub_station.execute(register_file, memory)
        if completed_station_sub:
            sub_station.release(completed_station_sub)
            completed_instructions += 1
        
        completed_station_load = load_station.execute(register_file, memory)
        if completed_station_load:
            load_station.release(completed_station_load)
            completed_instructions += 1
        
        completed_station_store = store_station.execute(register_file, memory)
        if completed_station_store:
            store_station.release(completed_station_store)
            completed_instructions += 1
        
        completed_station_nand = nand_station.execute(register_file, memory)
        if completed_station_nand:
            nand_station.release(completed_station_nand)
            completed_instructions += 1
        
        completed_station_branch = branch_station.execute(register_file, memory)
        if completed_station_branch:
            branch_station.release(completed_station_branch)
            completed_instructions += 1

        clock_cycles += 1

        # Commit results from reorder buffer after execution
        if completed_instructions == total_instructions:
            break

    # Calculate ICP (Instruction Completion Percent)
    if total_instructions > 0:
        icp = (completed_instructions / total_instructions) * 100
        print(f"\nICP (Instruction Completion Percent): {icp}%")





if __name__ == "__main__":
    main()


